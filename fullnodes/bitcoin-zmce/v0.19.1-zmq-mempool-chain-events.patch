diff --git a/PATCH.md b/PATCH.md
new file mode 100644
index 000000000..1c271ae9e
--- /dev/null
+++ b/PATCH.md
@@ -0,0 +1,176 @@
+# Patch: Mempool and Chain event publishers for ZMQ
+
+This is a patch-set to Bitcoin Core that adds more functionality to the ZMQ interface.
+While the patches does not touch consensus or wallet code, it's not recommended to use this node in a consensus critical environment where user
+funds are at risk.
+
+## Changes:
+
+### add: multi-payload ZMQ multipart messages
+
+A new internal function overwrite for `zmq_send_multipart()` is added.
+This allows us to send ZMQ multipart messages with a variable amount (zero to many) of payload parts.
+
+```
+ZMQ multipart message structure
+Before: | topic | payload | sequence |
+After:  | topic | payload_0 | payload_1 | ... | payload_n | sequence |
+```
+
+This change is backward compatible to the format of the existing ZMQ publishers.
+The topic is the first part of the message and the sequence is the last part of the message.
+
+### add: ZMQ publisher for mempool added with tx+fee
+
+A new ZMQ publisher with the topic `mempooladded` is added.
+The command line option `-zmqpubmempooladded=<address>` sets the address for the publisher and `-zmqpubmempooladdedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a transaction is added to the mempool and passes the txid, the raw transaction and the fee paid.
+
+The functional tests for this ZMQ publisher can be run with `python3 test/functional/test_runner.py test/functional/interface_zmq_mempooladd.py`. Make sure bitcoind is compiled with a wallet otherwise the tests are skipped.
+
+#### Specification
+```
+ZMQ multipart message structure
+| topic | txid | rawtx | fee | sequence |
+```
+
+- `topic` equals `mempooladded`
+- `txid` is the transaction id
+- `rawtx` is a serialized Bitcoin transaction
+- `fee` is a `int64` in Little Endian
+- `sequence` is a `uint32` in Little Endian
+
+### add: ZMQ publisher for mempool removed tx+reason
+
+A new ZMQ publisher with the topic `mempoolremoved` is added.
+The command line option `-zmqpubmempoolremoved=<address>` sets the address for the publisher and `-zmqpubmempoolremovedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a transaction is removed from the mempool and passes the txid, the raw transaction, and the removal reason.
+
+| Value | Name | Description |
+|:-----:|:----------:|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
+| 0 | Expiry | Transactions in the Mempool can expire. The default expiry timeout is 336 hours (2 weeks). |
+| 1 | Size limit | As the internal data structure storing the Mempool gets close to `maxmempool` (default 300MB) low feerate transactions are evicted. |
+| 2 | Reorg | Transactions that become invalid after a reorg are evicted. Note: Often transactions are still valid after a reorg. A transaction that might become valid is, for example, a transaction that spends a now not-mature coinbase output. |
+| 3 | Block | Transactions included in a block of the most-work chain are removed from the Mempool. |
+| 4 | Conflict | Transactions conflicting with an in-block transaction are removed. |
+| 5 | Replaced | Transactions that are replaced are removed from the Mempool.  |                                                                                                                                                                      |
+
+The functional tests for this ZMQ publisher can be run with `python3 test/functional/test_runner.py test/functional/interface_zmq_mempoolremove*`. Make sure `bitcoind` is compiled with a wallet otherwise the tests are skipped.
+
+#### Specification
+```
+ZMQ multipart message structure
+| topic | txid | rawtx | removal reason | sequence |
+```
+
+- `topic` equals `mempoolremoved`
+- `txid` is the transaction id
+- `rawtx` is a serialized Bitcoin transaction
+- `removal reason` is an `int` in Little Endian
+- `sequence` is an `uint32` in Little Endian
+
+### add: ZMQ publisher for block connected
+
+A new ZMQ publisher with the topic `chainconnected` is added.
+The command-line option `-zmqpubchainconnected=<address>` sets the address for the publisher and `-zmqpubchainconnectedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a block is connected to a branch on a chain. Note: This block does not need to be the the most-work chain.
+
+The functional tests for this ZMQ publisher can be run with `python3 test/functional/test_runner.py interface_zmq_chainblockconnected.py`.
+
+#### Specification
+```
+ZMQ multipart message structure
+| topic | hash | height | prev hash | rawblock | sequence |
+```
+
+- `topic` equals `chainconnected`
+- `hash` is the block hash
+- `height` is the block height as `int32` in Little Endian
+- `prev hash` is the previous block hash
+- `block` is a serialized Bitcoin block
+- `sequence` is an `uint32` in Little Endian
+
+### add: ZMQ publisher for mempool replacements
+
+A new ZMQ publisher with the topic `mempoolreplaced` is added.
+The command-line option `-zmqpubmempoolreplaced=<address>` sets the address for the publisher and `-zmqpubmempoolreplacedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a transaction in the mempool is replaced. This includes both the transaction id and raw transaction of the replaced and the replacement transaction as well as their fees.
+
+The functional tests for this ZMQ publisher can be run with `python3 test/functional/test_runner.py interface_zmq_mempoolreplace.py`.
+
+#### Specification
+```
+ZMQ multipart message structure
+| topic | txid replaced | rawtx replaced | fee replaced | txid replacement | rawtx replacement | fee replacement | sequence |
+```
+
+- `topic` equals `mempoolreplaced`
+- `txid replaced` is the txid of the replaced transaction
+- `rawtx replaced` is the serialized Bitcoin transaction that is replaced
+- `fee replaced` is the fee of the replaced transaction as a `int64_t` in Little Endian
+- `txid replacement` is the txid of the replacement transaction
+- `rawtx replacement` is the serialized Bitcoin transaction that is the replacement
+- `fee replacement` is the fee of the replacement transaction as a `int64_t` in Little Endian
+- `sequence` is an `uint32` in Little Endian
+
+### add: ZMQ publisher for mempool confirmations
+
+A new ZMQ publisher with the topic `mempoolconfirmed` is added.
+The command line option `-zmqpubmempoolconfirmed=<address>` sets the address for the publisher and `-zmqpubmempoolconfirmedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a transaction is included in a block and passes the txid, the raw transaction, the block height and the block hash.
+
+The functional tests for this ZMQ publisher can be run with `python3 test/functional/test_runner.py test/functional/interface_zmq_mempoolconfirmed.py`. Make sure bitcoind is compiled with a wallet otherwise the tests are skipped.
+
+#### Specification
+```
+ZMQ multipart message structure
+| topic | txid | rawtx | block height | block hash | prev hash | sequence |
+```
+
+- `topic` equals `mempoolconfirmed`
+- `txid` is the transaction id
+- `rawtx` is a serialized Bitcoin transaction
+- `block height` is the block height as `int32` in Little Endian
+- `block hash` is the block hash
+- `prev hash` is the previous block hash
+- `sequence` is a `uint32` in Little Endian
+
+### add: ZMQ publisher for chain tip changed
+
+A new ZMQ publisher with the topic `chaintipchanged` is added.
+The command-line option `-zmqpubchaintipchanged=<address>` sets the address for the publisher and `-zmqpubchaintipchangedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a block is connected to a branch on a chain. Note: This block does not need to be the the most-work chain.
+
+The functional tests for this ZMQ publisher can be run with `python3 test/functional/test_runner.py interface_zmq_chaintipchanged.py`.
+
+#### Specification
+```
+ZMQ multipart message structure
+| topic | hash | height | prev hash | sequence |
+```
+
+- `topic` equals `chaintipchanged`
+- `hash` is the block hash
+- `height` is the block height as `int32` in Little Endian
+- `prev hash` is the previous block hash (**not** the previous tip hash!)
+- `sequence` is an `uint32` in Little Endian
+
+### add: ZMQ publisher for header added
+
+A new ZMQ publisher with the topic `chainheaderadded` is added.
+The command-line option `-zmqpubchainheaderadded=<address>` sets the address for the publisher and `-zmqpubchainheaderaddedhwm=<n>` sets a custom outbound message high water mark.
+The publisher notifies when a header is connected to a branch on a chain. Note: This header addition does not need to be on the the most-work chain.
+
+The functional tests for this ZMQ publisher can be run with `python3 test/functional/test_runner.py interface_zmq_chainheaderadded.py`.
+
+#### Specification
+```
+ZMQ multipart message structure
+| topic | hash | height | prev hash | sequence |
+```
+
+- `topic` equals `chainheaderadded`
+- `hash` is the block hash
+- `height` is the block height as `int32` in Little Endian
+- `prev hash` is the previous block hash
+- `sequence` is an `uint32` in Little Endian
diff --git a/src/init.cpp b/src/init.cpp
index ccb5962c4..be25bba52 100644
--- a/src/init.cpp
+++ b/src/init.cpp
@@ -466,6 +466,21 @@ void SetupServerArgs()
     gArgs.AddArg("-zmqpubhashtxhwm=<n>", strprintf("Set publish hash transaction outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     gArgs.AddArg("-zmqpubrawblockhwm=<n>", strprintf("Set publish raw block outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
     gArgs.AddArg("-zmqpubrawtxhwm=<n>", strprintf("Set publish raw transaction outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+
+    gArgs.AddArg("-zmqpubmempooladded=<address>", "Enable publish raw transaction with fee in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubmempooladdedhwm=<n>", strprintf("Set publish raw transaction with fee outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubmempoolremoved=<address>", "Enable publish removed raw transaction with reason in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubmempoolremovedhwm=<n>", strprintf("Set publish removed raw transaction with reason outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubchainconnected=<address>", "Enable publish raw block connected in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubchainconnectedhwm=<n>", strprintf("Set publish raw block connected outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubmempoolreplaced=<address>", "Enable publish replaced raw transaction in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubmempoolreplacedhwm=<n>", strprintf("Set publish replaced raw transaction outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubmempoolconfirmed=<address>", "Enable publish confirmed raw transaction in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubmempoolconfirmedhwm=<n>", strprintf("Set publish confirmed raw transaction outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubchaintipchanged=<address>", "Enable publish tip changed events in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubchaintipchangedhwm=<n>", strprintf("Set tip changed outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubchainheaderadded=<address>", "Enable publish header added events in <address>", ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
+    gArgs.AddArg("-zmqpubchainheaderaddedhwm=<n>", strprintf("Set header added outbound message high water mark (default: %d)", CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM), ArgsManager::ALLOW_ANY, OptionsCategory::ZMQ);
 #else
     hidden_args.emplace_back("-zmqpubhashblock=<address>");
     hidden_args.emplace_back("-zmqpubhashtx=<address>");
@@ -475,6 +490,21 @@ void SetupServerArgs()
     hidden_args.emplace_back("-zmqpubhashtxhwm=<n>");
     hidden_args.emplace_back("-zmqpubrawblockhwm=<n>");
     hidden_args.emplace_back("-zmqpubrawtxhwm=<n>");
+
+    hidden_args.emplace_back("-zmqpubmempooladded=<address>");
+    hidden_args.emplace_back("-zmqpubmempooladdedhwm=<n>");
+    hidden_args.emplace_back("-zmqpubmempoolremoved=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolremovedhwm=<address>");
+    hidden_args.emplace_back("-zmqpubchainconnected=<address>");
+    hidden_args.emplace_back("-zmqpubchainconnectedhwm=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolreplaced=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolreplacedhwm=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolconfirmed=<address>");
+    hidden_args.emplace_back("-zmqpubmempoolconfirmedhwm=<address>");
+    hidden_args.emplace_back("-zmqpubchaintipchanged=<address>");
+    hidden_args.emplace_back("-zmqpubchaintipchangedhwm=<address>");
+    hidden_args.emplace_back("-zmqpubchainheaderadded=<address>");
+    hidden_args.emplace_back("-zmqpubchainheaderaddedhwm=<address>");
 #endif
 
     gArgs.AddArg("-checkblocks=<n>", strprintf("How many blocks to check at startup (default: %u, 0 = all)", DEFAULT_CHECKBLOCKS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);
diff --git a/src/interfaces/chain.cpp b/src/interfaces/chain.cpp
index aa44a69f0..cff51bf33 100644
--- a/src/interfaces/chain.cpp
+++ b/src/interfaces/chain.cpp
@@ -193,6 +193,22 @@ public:
     {
         m_notifications->UpdatedBlockTip();
     }
+    void TransactionAddedToMempoolWithFee(const CTransactionRef& tx, const CAmount fee) override
+    {
+        m_notifications->TransactionAddedToMempoolWithFee(tx, fee);
+    }
+    void TransactionRemovedFromMempoolWithReason(const CTransactionRef& tx, const MemPoolRemovalReason reason) override
+    {
+        m_notifications->TransactionRemovedFromMempoolWithReason(tx, reason);
+    }
+    void TransactionReplacedInMempool(const CTransactionRef& replaced, const CAmount replaced_tx_fee, const CTransactionRef& replacment, const CAmount replacment_tx_fee) override
+    {
+        m_notifications->TransactionReplacedInMempool(replaced, replaced_tx_fee, replacment, replacment_tx_fee);
+    }
+    void HeaderAddedToChain(const CBlockIndex* index) override
+    {
+        m_notifications->HeaderAddedToChain();
+    }
     void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->ChainStateFlushed(locator); }
     Chain& m_chain;
     Chain::Notifications* m_notifications;
diff --git a/src/interfaces/chain.h b/src/interfaces/chain.h
index e09958600..ec6ff9c96 100644
--- a/src/interfaces/chain.h
+++ b/src/interfaces/chain.h
@@ -19,12 +19,15 @@ class CFeeRate;
 class CRPCCommand;
 class CScheduler;
 class CValidationState;
+class CBlockIndex;
 class Coin;
 class uint256;
 enum class RBFTransactionState;
 struct CBlockLocator;
 struct FeeCalculation;
 
+enum class MemPoolRemovalReason;
+
 namespace interfaces {
 
 class Handler;
@@ -222,6 +225,11 @@ public:
         virtual void BlockDisconnected(const CBlock& block) {}
         virtual void UpdatedBlockTip() {}
         virtual void ChainStateFlushed(const CBlockLocator& locator) {}
+
+        virtual void TransactionAddedToMempoolWithFee(const CTransactionRef& tx, const CAmount fee) {}
+        virtual void TransactionRemovedFromMempoolWithReason(const CTransactionRef& ptx, const MemPoolRemovalReason reason) {}
+        virtual void TransactionReplacedInMempool(const CTransactionRef& replaced, const CAmount replaced_tx_fee, const CTransactionRef& replacment, const CAmount replacment_tx_fee) {}
+        virtual void HeaderAddedToChain() {}
     };
 
     //! Register handler for notifications.
diff --git a/src/txmempool.cpp b/src/txmempool.cpp
index 9257cff71..4a03e5683 100644
--- a/src/txmempool.cpp
+++ b/src/txmempool.cpp
@@ -17,6 +17,8 @@
 #include <util/moneystr.h>
 #include <util/time.h>
 
+#include <validationinterface.h>
+
 CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFee,
                                  int64_t _nTime, unsigned int _entryHeight,
                                  bool _spendsCoinbase, int64_t _sigOpsCost, LockPoints lp)
@@ -402,6 +404,8 @@ void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAnces
 
 void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)
 {
+    GetMainSignals().TransactionRemovedFromMempoolWithReason(it->GetSharedTx(), reason);
+    
     NotifyEntryRemoved(it->GetSharedTx(), reason);
     const uint256 hash = it->GetTx().GetHash();
     for (const CTxIn& txin : it->GetTx().vin)
diff --git a/src/validation.cpp b/src/validation.cpp
index ac98bd61c..6deab3944 100644
--- a/src/validation.cpp
+++ b/src/validation.cpp
@@ -994,6 +994,9 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)
                 hash.ToString(),
                 FormatMoney(nModifiedFees - nConflictingFees),
                 (int)entry->GetTxSize() - (int)nConflictingSize);
+        
+        GetMainSignals().TransactionReplacedInMempool(it->GetSharedTx(), nConflictingFees, ws.m_ptx, ws.m_modified_fees);
+
         if (args.m_replaced_transactions)
             args.m_replaced_transactions->push_back(it->GetSharedTx());
     }
@@ -1044,6 +1047,8 @@ bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs
 
     GetMainSignals().TransactionAddedToMempool(ptx);
 
+    GetMainSignals().TransactionAddedToMempoolWithFee(ptx, workspace.m_entry->GetFee());
+    
     return true;
 }
 
@@ -3131,6 +3136,10 @@ CBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)
 
     setDirtyBlockIndex.insert(pindexNew);
 
+    if (!fImporting && !fReindex) {
+        GetMainSignals().HeaderAddedToChain(pindexNew);
+    }
+
     return pindexNew;
 }
 
diff --git a/src/validationinterface.cpp b/src/validationinterface.cpp
index 59a620ab9..0dcd653d7 100644
--- a/src/validationinterface.cpp
+++ b/src/validationinterface.cpp
@@ -25,6 +25,11 @@ struct ValidationInterfaceConnections {
     boost::signals2::scoped_connection ChainStateFlushed;
     boost::signals2::scoped_connection BlockChecked;
     boost::signals2::scoped_connection NewPoWValidBlock;
+
+    boost::signals2::scoped_connection TransactionAddedToMempoolWithFee;
+    boost::signals2::scoped_connection TransactionRemovedFromMempoolWithReason;
+    boost::signals2::scoped_connection TransactionReplacedInMempool;
+    boost::signals2::scoped_connection HeaderAddedToChain;
 };
 
 struct MainSignalsInstance {
@@ -36,7 +41,11 @@ struct MainSignalsInstance {
     boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;
     boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;
     boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;
-
+    boost::signals2::signal<void (const CTransactionRef &, const CAmount)> TransactionAddedToMempoolWithFee;
+    boost::signals2::signal<void (const CTransactionRef &, const MemPoolRemovalReason)> TransactionRemovedFromMempoolWithReason;
+    boost::signals2::signal<void (const CTransactionRef &, const CAmount, const CTransactionRef&, const CAmount)> TransactionReplacedInMempool;
+    boost::signals2::signal<void (const CBlockIndex *)> HeaderAddedToChain;
+    
     // We are not allowed to assume the scheduler only runs in one thread,
     // but must ensure all callbacks happen in-order, so we end up creating
     // our own queue here :(
@@ -99,6 +108,11 @@ void RegisterValidationInterface(CValidationInterface* pwalletIn) {
     conns.ChainStateFlushed = g_signals.m_internals->ChainStateFlushed.connect(std::bind(&CValidationInterface::ChainStateFlushed, pwalletIn, std::placeholders::_1));
     conns.BlockChecked = g_signals.m_internals->BlockChecked.connect(std::bind(&CValidationInterface::BlockChecked, pwalletIn, std::placeholders::_1, std::placeholders::_2));
     conns.NewPoWValidBlock = g_signals.m_internals->NewPoWValidBlock.connect(std::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, std::placeholders::_1, std::placeholders::_2));
+
+    conns.TransactionAddedToMempoolWithFee = g_signals.m_internals->TransactionAddedToMempoolWithFee.connect(std::bind(&CValidationInterface::TransactionAddedToMempoolWithFee, pwalletIn, std::placeholders::_1, std::placeholders::_2));
+    conns.TransactionRemovedFromMempoolWithReason = g_signals.m_internals->TransactionRemovedFromMempoolWithReason.connect(std::bind(&CValidationInterface::TransactionRemovedFromMempoolWithReason, pwalletIn, std::placeholders::_1, std::placeholders::_2));
+    conns.TransactionReplacedInMempool = g_signals.m_internals->TransactionReplacedInMempool.connect(std::bind(&CValidationInterface::TransactionReplacedInMempool, pwalletIn, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4));
+    conns.HeaderAddedToChain = g_signals.m_internals->HeaderAddedToChain.connect(std::bind(&CValidationInterface::HeaderAddedToChain, pwalletIn, std::placeholders::_1));
 }
 
 void UnregisterValidationInterface(CValidationInterface* pwalletIn) {
@@ -177,3 +191,27 @@ void CMainSignals::BlockChecked(const CBlock& block, const CValidationState& sta
 void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block) {
     m_internals->NewPoWValidBlock(pindex, block);
 }
+
+void CMainSignals::TransactionAddedToMempoolWithFee(const CTransactionRef &ptx, const CAmount fee) {
+    m_internals->m_schedulerClient.AddToProcessQueue([ptx, fee, this] {
+        m_internals->TransactionAddedToMempoolWithFee(ptx, fee);
+    });
+}
+
+void CMainSignals::TransactionRemovedFromMempoolWithReason(const CTransactionRef &ptx, const MemPoolRemovalReason reason) {
+    m_internals->m_schedulerClient.AddToProcessQueue([ptx, reason, this] {
+        m_internals->TransactionRemovedFromMempoolWithReason(ptx, reason);
+    });
+}
+
+void CMainSignals::TransactionReplacedInMempool(const CTransactionRef &replaced, const CAmount replaced_tx_fee, const CTransactionRef &replacement, const CAmount replacement_tx_fee) {
+    m_internals->m_schedulerClient.AddToProcessQueue([replaced, replaced_tx_fee, replacement, replacement_tx_fee, this] {
+        m_internals->TransactionReplacedInMempool(replaced, replaced_tx_fee, replacement, replacement_tx_fee);
+    });
+}
+
+void CMainSignals::HeaderAddedToChain(const CBlockIndex *pindexHeader) {
+    m_internals->m_schedulerClient.AddToProcessQueue([pindexHeader, this] {
+        m_internals->HeaderAddedToChain(pindexHeader);
+    });
+}
\ No newline at end of file
diff --git a/src/validationinterface.h b/src/validationinterface.h
index 3ce617b82..27b39ac19 100644
--- a/src/validationinterface.h
+++ b/src/validationinterface.h
@@ -143,6 +143,36 @@ protected:
      * Notifies listeners that a block which builds directly on our current tip
      * has been received and connected to the headers tree, though not validated yet */
     virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};
+
+    /**
+     * Notifies listeners of a transaction having been added to mempool and passed the transaction fee.
+     *
+     * Called on a background thread.
+     */
+    virtual void TransactionAddedToMempoolWithFee(const CTransactionRef&, const CAmount) {}
+
+    /**
+     * Notifies listeners of a transaction leaving mempool and passes the reason.
+     *
+     * Called on a background thread.
+     */
+    virtual void TransactionRemovedFromMempoolWithReason(const CTransactionRef&, const MemPoolRemovalReason) {}
+
+    /**
+     * Notifies listeners of a transaction being replaced in the mempool and passes 
+     * the replaced and replacment transaction as well as their fees paid.
+     *
+     * Called on a background thread.
+     */
+    virtual void TransactionReplacedInMempool(const CTransactionRef&, const CAmount, const CTransactionRef&, const CAmount) {}
+
+    /**
+     * Notifies listeners when a new header is added to one of the branches of the chain.
+     *
+     * Called on a background thread.
+     */
+    virtual void HeaderAddedToChain(const CBlockIndex *pindexHeader) {}
+    
     friend void ::RegisterValidationInterface(CValidationInterface*);
     friend void ::UnregisterValidationInterface(CValidationInterface*);
     friend void ::UnregisterAllValidationInterfaces();
@@ -182,6 +212,11 @@ public:
     void ChainStateFlushed(const CBlockLocator &);
     void BlockChecked(const CBlock&, const CValidationState&);
     void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);
+
+    void TransactionAddedToMempoolWithFee(const CTransactionRef &, const CAmount);
+    void TransactionRemovedFromMempoolWithReason(const CTransactionRef &, const MemPoolRemovalReason);
+    void TransactionReplacedInMempool(const CTransactionRef &, const CAmount, const CTransactionRef &, const CAmount);
+    void HeaderAddedToChain(const CBlockIndex *);
 };
 
 CMainSignals& GetMainSignals();
diff --git a/src/zmq/zmqabstractnotifier.cpp b/src/zmq/zmqabstractnotifier.cpp
index a5f3be8f5..02efe3070 100644
--- a/src/zmq/zmqabstractnotifier.cpp
+++ b/src/zmq/zmqabstractnotifier.cpp
@@ -4,6 +4,8 @@
 
 #include <zmq/zmqabstractnotifier.h>
 
+#include <txmempool.h>
+
 const int CZMQAbstractNotifier::DEFAULT_ZMQ_SNDHWM;
 
 CZMQAbstractNotifier::~CZMQAbstractNotifier()
@@ -20,3 +22,38 @@ bool CZMQAbstractNotifier::NotifyTransaction(const CTransaction &/*transaction*/
 {
     return true;
 }
+
+bool CZMQAbstractNotifier::NotifyMempoolTransactionAdded(const CTransaction &/*transaction*/, const CAmount/*fee*/)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyMempoolTransactionRemoved(const CTransaction &/*transaction*/, const MemPoolRemovalReason /*reason*/)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyChainBlockConnected(const CBlockIndex * /*CBlockIndex*/)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyMempoolTransactionReplaced(const CTransaction &/*replaced*/, const CAmount/*replaced tx fee*/, const CTransaction &/*replacment*/, const CAmount/*replacement tx fee*/)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyMempoolTransactionConfirmed(const CTransaction &/*transaction*/, const CBlockIndex *)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyChainTipChanged(const CBlockIndex *)
+{
+    return true;
+}
+
+bool CZMQAbstractNotifier::NotifyChainHeaderAdded(const CBlockIndex *)
+{
+    return true;
+}
\ No newline at end of file
diff --git a/src/zmq/zmqabstractnotifier.h b/src/zmq/zmqabstractnotifier.h
index 887dde7b2..a83968b50 100644
--- a/src/zmq/zmqabstractnotifier.h
+++ b/src/zmq/zmqabstractnotifier.h
@@ -7,6 +7,8 @@
 
 #include <zmq/zmqconfig.h>
 
+#include <txmempool.h>
+
 class CBlockIndex;
 class CZMQAbstractNotifier;
 
@@ -43,6 +45,14 @@ public:
     virtual bool NotifyBlock(const CBlockIndex *pindex);
     virtual bool NotifyTransaction(const CTransaction &transaction);
 
+    virtual bool NotifyMempoolTransactionAdded(const CTransaction &transaction, const CAmount fee);
+    virtual bool NotifyMempoolTransactionRemoved(const CTransaction &transaction, const MemPoolRemovalReason reason);
+
+    virtual bool NotifyChainBlockConnected(const CBlockIndex *pindex);
+    virtual bool NotifyMempoolTransactionReplaced(const CTransaction &replaced, const CAmount replaced_tx_fee, const CTransaction &replacement, const CAmount replacement_tx_fee);
+    virtual bool NotifyMempoolTransactionConfirmed(const CTransaction &transaction, const CBlockIndex *pindex);
+    virtual bool NotifyChainTipChanged(const CBlockIndex *pindex);
+    virtual bool NotifyChainHeaderAdded(const CBlockIndex *pindex);
 protected:
     void *psocket;
     std::string type;
diff --git a/src/zmq/zmqnotificationinterface.cpp b/src/zmq/zmqnotificationinterface.cpp
index de59b71b8..fd076bb53 100644
--- a/src/zmq/zmqnotificationinterface.cpp
+++ b/src/zmq/zmqnotificationinterface.cpp
@@ -48,6 +48,14 @@ CZMQNotificationInterface* CZMQNotificationInterface::Create()
     factories["pubrawblock"] = CZMQAbstractNotifier::Create<CZMQPublishRawBlockNotifier>;
     factories["pubrawtx"] = CZMQAbstractNotifier::Create<CZMQPublishRawTransactionNotifier>;
 
+    factories["pubmempooladded"] = CZMQAbstractNotifier::Create<CZMQPublishMempolAddedNotifier>;
+    factories["pubmempoolremoved"] = CZMQAbstractNotifier::Create<CZMQPublishMempoolRemovedNotifier>;
+    factories["pubchainconnected"] = CZMQAbstractNotifier::Create<CZMQPublishChainConnectedNotifier>;
+    factories["pubmempoolreplaced"] = CZMQAbstractNotifier::Create<CZMQPublishMempolReplacedNotifier>;
+    factories["pubmempoolconfirmed"] = CZMQAbstractNotifier::Create<CZMQPublishMempoolConfirmedNotifier>;
+    factories["pubchaintipchanged"] = CZMQAbstractNotifier::Create<CZMQPublishChainTipChangedNotifier>;
+    factories["pubchainheaderadded"] = CZMQAbstractNotifier::Create<CZMQPublishChainHeaderAddedNotifier>;
+    
     for (const auto& entry : factories)
     {
         std::string arg("-zmq" + entry.first);
@@ -155,6 +163,20 @@ void CZMQNotificationInterface::UpdatedBlockTip(const CBlockIndex *pindexNew, co
             i = notifiers.erase(i);
         }
     }
+
+    for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )
+    {
+        CZMQAbstractNotifier *notifier = *i;
+        if (notifier->NotifyChainTipChanged(pindexNew))
+        {
+            i++;
+        }
+        else
+        {
+            notifier->Shutdown();
+            i = notifiers.erase(i);
+        }
+    }
 }
 
 void CZMQNotificationInterface::TransactionAddedToMempool(const CTransactionRef& ptx)
@@ -178,12 +200,83 @@ void CZMQNotificationInterface::TransactionAddedToMempool(const CTransactionRef&
     }
 }
 
+void CZMQNotificationInterface::TransactionAddedToMempoolWithFee(const CTransactionRef& ptx, const CAmount fee)
+{
+    const CTransaction& tx = *ptx;
+    for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )
+    {
+        CZMQAbstractNotifier *notifier = *i;
+        if (notifier->NotifyMempoolTransactionAdded(tx, fee))
+        {
+            i++;
+        }
+        else
+        {
+            notifier->Shutdown();
+            i = notifiers.erase(i);
+        }
+    }
+}
+
+void CZMQNotificationInterface::TransactionRemovedFromMempoolWithReason(const CTransactionRef& ptx, const MemPoolRemovalReason reason)
+{
+    const CTransaction& tx = *ptx;
+    for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )
+    {
+        CZMQAbstractNotifier *notifier = *i;
+        if (notifier->NotifyMempoolTransactionRemoved(tx, reason))
+        {
+            i++;
+        }
+        else
+        {
+            notifier->Shutdown();
+            i = notifiers.erase(i);
+        }
+    }
+}
+
 void CZMQNotificationInterface::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted)
 {
     for (const CTransactionRef& ptx : pblock->vtx) {
         // Do a normal notify for each transaction added in the block
         TransactionAddedToMempool(ptx);
     }
+
+    for (const CTransactionRef& ptx : pblock->vtx) {
+        const CTransaction& tx = *ptx;
+        
+        // do not notify on coinbase tx
+        if (tx.IsCoinBase()) continue;
+        
+        for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )
+        {
+            CZMQAbstractNotifier *notifier = *i;
+            if (notifier->NotifyMempoolTransactionConfirmed(tx, pindexConnected))
+            {
+                i++;
+            }
+            else
+            {
+                notifier->Shutdown();
+                i = notifiers.erase(i);
+            }
+        }
+    }
+
+    for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )
+    {
+        CZMQAbstractNotifier *notifier = *i;
+        if (notifier->NotifyChainBlockConnected(pindexConnected))
+        {
+            i++;
+        }
+        else
+        {
+            notifier->Shutdown();
+            i = notifiers.erase(i);
+        }
+    }
 }
 
 void CZMQNotificationInterface::BlockDisconnected(const std::shared_ptr<const CBlock>& pblock)
@@ -194,4 +287,41 @@ void CZMQNotificationInterface::BlockDisconnected(const std::shared_ptr<const CB
     }
 }
 
+void CZMQNotificationInterface::TransactionReplacedInMempool(const CTransactionRef& replaced, const CAmount replaced_tx_fee, const CTransactionRef& replacement, const CAmount replacement_tx_fee)
+{
+    const CTransaction& replaced_tx = *replaced;
+    const CTransaction& replacement_tx = *replacement;
+    for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )
+    {
+        CZMQAbstractNotifier *notifier = *i;
+        if (notifier->NotifyMempoolTransactionReplaced(replaced_tx, replaced_tx_fee, replacement_tx, replacement_tx_fee))
+        {
+            i++;
+        }
+        else
+        {
+            notifier->Shutdown();
+            i = notifiers.erase(i);
+        }
+    }
+}
+
+void CZMQNotificationInterface::HeaderAddedToChain(const CBlockIndex *pindexHeader)
+{
+   
+    for (std::list<CZMQAbstractNotifier*>::iterator i = notifiers.begin(); i!=notifiers.end(); )
+    {
+        CZMQAbstractNotifier *notifier = *i;
+        if (notifier->NotifyChainHeaderAdded(pindexHeader))
+        {
+            i++;
+        }
+        else
+        {
+            notifier->Shutdown();
+            i = notifiers.erase(i);
+        }
+    }
+}
+
 CZMQNotificationInterface* g_zmq_notification_interface = nullptr;
diff --git a/src/zmq/zmqnotificationinterface.h b/src/zmq/zmqnotificationinterface.h
index a0cc26a16..ae91a40d5 100644
--- a/src/zmq/zmqnotificationinterface.h
+++ b/src/zmq/zmqnotificationinterface.h
@@ -32,6 +32,11 @@ protected:
     void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override;
     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;
 
+    void TransactionAddedToMempoolWithFee(const CTransactionRef& tx, const CAmount fee) override;
+    void TransactionRemovedFromMempoolWithReason(const CTransactionRef& ptx, const MemPoolRemovalReason reason) override;
+    
+    void TransactionReplacedInMempool(const CTransactionRef& replaced, const CAmount replaced_tx_fee, const CTransactionRef& replacement, const CAmount replacement_tx_fee) override;
+    void HeaderAddedToChain(const CBlockIndex *pindexHeader) override;
 private:
     CZMQNotificationInterface();
 
diff --git a/src/zmq/zmqpublishnotifier.cpp b/src/zmq/zmqpublishnotifier.cpp
index 233a45d19..53d5b02a6 100644
--- a/src/zmq/zmqpublishnotifier.cpp
+++ b/src/zmq/zmqpublishnotifier.cpp
@@ -17,6 +17,14 @@ static const char *MSG_HASHTX    = "hashtx";
 static const char *MSG_RAWBLOCK  = "rawblock";
 static const char *MSG_RAWTX     = "rawtx";
 
+static const char *MSG_MEMPOOLADDED = "mempooladded";
+static const char *MSG_MEMPOOLREMOVED = "mempoolremoved";
+static const char *MSG_CHAINCONNECTED = "chainconnected";
+static const char *MSG_MEMPOOLREPLACED = "mempoolreplaced";
+static const char *MSG_MEMPOOLCONFIRMED = "mempoolconfirmed";
+static const char *MSG_CHAINTIPCHANGED = "chaintipchanged";
+static const char *MSG_CHAINHEADERADDED = "chainheaderadded";
+
 // Internal function to send multipart message
 static int zmq_send_multipart(void *sock, const void* data, size_t size, ...)
 {
@@ -60,6 +68,35 @@ static int zmq_send_multipart(void *sock, const void* data, size_t size, ...)
     return 0;
 }
 
+static int zmq_send_multipart(void *sock, const zmq_message& message)
+{
+    for (size_t i = 0; i < message.size(); i++) {
+        auto const& part = message[i];
+        zmq_msg_t msg;
+
+        int rc = zmq_msg_init_size(&msg, part.size());
+        if (rc != 0) {
+            zmqError("Unable to initialize ZMQ msg");
+            return -1;
+        }
+
+        void* buf = zmq_msg_data(&msg);
+        std::memcpy(buf, part.data(), part.size());
+
+        rc = zmq_msg_send(&msg, sock, (i < (message.size() - 1)) ? ZMQ_SNDMORE : 0);
+        if (rc == -1) {
+            zmqError("Unable to send ZMQ msg");
+            zmq_msg_close(&msg);
+            return -1;
+        }
+
+        zmq_msg_close(&msg);
+    }
+
+    LogPrint(BCLog::ZMQ, "sent message with %d parts\n", message.size());
+    return 0;
+}
+
 bool CZMQAbstractPublishNotifier::Initialize(void *pcontext)
 {
     assert(!psocket);
@@ -158,6 +195,42 @@ bool CZMQAbstractPublishNotifier::SendMessage(const char *command, const void* d
     return true;
 }
 
+
+bool CZMQAbstractPublishNotifier::SendMessage(const char *command, const std::vector<zmq_message_part>& payload)
+{
+    assert(psocket);
+
+    /* 
+      create message from multiple parts:
+       - first part is the command (or topic)
+       - followed by one or multiple payload parts
+       - ended by a LE 4 byte sequence number 
+    */
+    std::vector<zmq_message_part> message = {};
+
+    // push topic
+    message.push_back(zmq_message_part(command, command + strlen(command)));
+
+    // push payload
+    for (size_t i = 0; i < payload.size(); i++)
+        message.push_back(payload[i]);
+    
+    // push little endian sequence number
+    unsigned char sequenceLE[sizeof(uint32_t)];
+    WriteLE32(&sequenceLE[0], nSequence);
+    message.push_back(zmq_message_part(sequenceLE, sequenceLE + sizeof(uint32_t)));
+
+
+    int rc = zmq_send_multipart(psocket, message);
+    if (rc == -1)
+        return false;
+
+    // increment memory only sequence number after sending
+    nSequence++;
+
+    return true;
+}
+
 bool CZMQPublishHashBlockNotifier::NotifyBlock(const CBlockIndex *pindex)
 {
     uint256 hash = pindex->GetBlockHash();
@@ -207,3 +280,239 @@ bool CZMQPublishRawTransactionNotifier::NotifyTransaction(const CTransaction &tr
     ss << transaction;
     return SendMessage(MSG_RAWTX, &(*ss.begin()), ss.size());
 }
+
+bool CZMQPublishMempolAddedNotifier::NotifyMempoolTransactionAdded(const CTransaction &transaction, const CAmount fee)
+{
+    uint256 txid = transaction.GetHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish mempooladded %s\n", txid.GetHex());
+    
+    std::vector<zmq_message_part> payload = {};
+    
+    // txid
+    zmq_message_part part_txid;
+    for (int i = 31; i >= 0; i--)
+        part_txid.push_back(txid.begin()[i]);
+    payload.push_back(part_txid);
+
+    // raw tx 
+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
+    ss << transaction;
+    payload.push_back(zmq_message_part(ss.begin() , ss.end()));
+
+    // fee (as int64_t)
+    unsigned char value[sizeof(fee)];
+    std::memcpy(value, &fee, sizeof(fee));
+    payload.push_back(zmq_message_part(value, value + sizeof(fee)));
+        
+    return SendMessage(MSG_MEMPOOLADDED, payload);
+}
+
+bool CZMQPublishMempoolRemovedNotifier::NotifyMempoolTransactionRemoved(const CTransaction &transaction, const MemPoolRemovalReason reason)
+{
+    uint256 txid = transaction.GetHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish mempoolremoved %s\n", txid.GetHex());
+    
+    std::vector<zmq_message_part> payload = {};
+
+    // txid
+    zmq_message_part part_txid;
+    for (int i = 31; i >= 0; i--)
+        part_txid.push_back(txid.begin()[i]);
+    payload.push_back(part_txid);
+
+    // raw tx 
+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
+    ss << transaction;
+    payload.push_back(zmq_message_part(ss.begin() , ss.end()));
+
+    // reason
+    unsigned char value[sizeof(reason)];
+    std::memcpy(value, &reason, sizeof(value));
+    payload.push_back(zmq_message_part(value, value + sizeof(value)));
+        
+    return SendMessage(MSG_MEMPOOLREMOVED, payload);
+}
+
+bool CZMQPublishMempoolConfirmedNotifier::NotifyMempoolTransactionConfirmed(const CTransaction &transaction, const CBlockIndex *pindex)
+{
+    uint256 txid = transaction.GetHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish mempoolconfirmed %s\n", txid.GetHex());
+    
+    std::vector<zmq_message_part> payload = {};
+
+    // txid
+    zmq_message_part part_txid;
+    for (int i = 31; i >= 0; i--)
+        part_txid.push_back(txid.begin()[i]);
+    payload.push_back(part_txid);
+
+    // raw tx 
+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
+    ss << transaction;
+    payload.push_back(zmq_message_part(ss.begin() , ss.end()));
+
+    // block height (as int32_t)
+    int32_t height = pindex->nHeight;
+    unsigned char value[sizeof(height)];
+    std::memcpy(value, &height, sizeof(height));
+    payload.push_back(zmq_message_part(value, value + sizeof(height)));
+
+    // block hash
+    uint256 hash = pindex->GetBlockHash();
+    zmq_message_part part_hash;
+    for (int i = 31; i >= 0; i--)
+        part_hash.push_back(hash.begin()[i]);
+    payload.push_back(part_hash);
+
+    // prev hash
+    uint256 prev_hash = pindex->pprev->GetBlockHash();
+    zmq_message_part part_prev_hash;
+    for (int i = 31; i >= 0; i--)   
+        part_prev_hash.push_back(prev_hash.begin()[i]);
+    payload.push_back(part_prev_hash);
+        
+    return SendMessage(MSG_MEMPOOLCONFIRMED, payload);
+}
+
+bool CZMQPublishChainConnectedNotifier::NotifyChainBlockConnected(const CBlockIndex *pindex)
+{
+    uint256 hash = pindex->GetBlockHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish chainconnected %s\n", hash.GetHex());
+    std::vector<zmq_message_part> payload = {};
+
+    // hash
+    zmq_message_part part_hash;
+    for (int i = 31; i >= 0; i--)
+        part_hash.push_back(hash.begin()[i]);
+    payload.push_back(part_hash);
+
+    // height (as int32_t)
+    int32_t height = pindex->nHeight;
+    unsigned char value[sizeof(height)];
+    std::memcpy(value, &height, sizeof(height));
+    payload.push_back(zmq_message_part(value, value + sizeof(height)));
+
+    // prev hash
+    uint256 prev_hash = pindex->pprev->GetBlockHash();
+    zmq_message_part part_prev_hash;
+    for (int i = 31; i >= 0; i--)   
+        part_prev_hash.push_back(prev_hash.begin()[i]);
+    payload.push_back(part_prev_hash);
+
+    const Consensus::Params& consensusParams = Params().GetConsensus();
+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
+    {
+        LOCK(cs_main);
+        CBlock block;
+        if(!ReadBlockFromDisk(block, pindex, consensusParams))
+        {
+            zmqError("Can't read block from disk");
+            return false;
+        }
+
+        ss << block;
+    }
+    payload.push_back(zmq_message_part(ss.begin() , ss.end()));
+
+    return SendMessage(MSG_CHAINCONNECTED, payload);
+}
+
+
+bool CZMQPublishMempolReplacedNotifier::NotifyMempoolTransactionReplaced(const CTransaction &replaced, const CAmount replaced_tx_fee, const CTransaction &replacement, const CAmount replacement_tx_fee)
+{
+    uint256 replaced_hash = replaced.GetHash();
+    uint256 replacement_hash = replacement.GetHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish mempoolreplaced %s by %s\n", replaced_hash.GetHex(), replacement_hash.GetHex());
+    
+    std::vector<zmq_message_part> payload = {};
+
+    // replaced txid
+    zmq_message_part replaced_txid;
+    for (int i = 31; i >= 0; i--)
+        replaced_txid.push_back(replaced_hash.begin()[i]);
+    payload.push_back(replaced_txid);
+
+    // replaced raw tx 
+    CDataStream ss_replaced(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
+    ss_replaced << replaced;
+    payload.push_back(zmq_message_part(ss_replaced.begin() , ss_replaced.end()));
+
+    // fee delta as int64_t
+    unsigned char value1[sizeof(replaced_tx_fee)];
+    std::memcpy(value1, &replaced_tx_fee, sizeof(replaced_tx_fee));
+    payload.push_back(zmq_message_part(value1, value1 + sizeof(replaced_tx_fee)));
+
+    // replacement txid
+    zmq_message_part replacement_txid;
+    for (int i = 31; i >= 0; i--)
+        replacement_txid.push_back(replacement_hash.begin()[i]);
+    payload.push_back(replacement_txid);
+
+    // replacement raw tx 
+    CDataStream ss_replacement(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
+    ss_replacement << replacement;
+    payload.push_back(zmq_message_part(ss_replacement.begin() , ss_replacement.end()));
+
+    // fee delta as int64_t
+    unsigned char value2[sizeof(replacement_tx_fee)];
+    std::memcpy(value2, &replacement_tx_fee, sizeof(replacement_tx_fee));
+    payload.push_back(zmq_message_part(value2, value2 + sizeof(replacement_tx_fee)));
+        
+    return SendMessage(MSG_MEMPOOLREPLACED, payload);
+}
+
+bool CZMQPublishChainTipChangedNotifier::NotifyChainTipChanged(const CBlockIndex *pindex)
+{
+    uint256 hash = pindex->GetBlockHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish chaintipchanged %s\n", hash.GetHex());
+    std::vector<zmq_message_part> payload = {};
+
+    // hash
+    zmq_message_part part_hash;
+    for (int i = 31; i >= 0; i--)
+        part_hash.push_back(hash.begin()[i]);
+    payload.push_back(part_hash);
+
+    // height (as int32_t)
+    int32_t height = pindex->nHeight;
+    unsigned char value[sizeof(height)];
+    std::memcpy(value, &height, sizeof(height));
+    payload.push_back(zmq_message_part(value, value + sizeof(height)));
+
+    // prev hash
+    uint256 prev_hash = pindex->pprev->GetBlockHash();
+    zmq_message_part part_prev_hash;
+    for (int i = 31; i >= 0; i--)   
+        part_prev_hash.push_back(prev_hash.begin()[i]);
+    payload.push_back(part_prev_hash);
+
+    return SendMessage(MSG_CHAINTIPCHANGED, payload);
+}
+
+bool CZMQPublishChainHeaderAddedNotifier::NotifyChainHeaderAdded(const CBlockIndex *pindex)
+{
+    uint256 hash = pindex->GetBlockHash();
+    LogPrint(BCLog::ZMQ, "zmq: Publish chainheaderadded %s\n", hash.GetHex());
+    std::vector<zmq_message_part> payload = {};
+
+    // hash
+    zmq_message_part part_hash;
+    for (int i = 31; i >= 0; i--)
+        part_hash.push_back(hash.begin()[i]);
+    payload.push_back(part_hash);
+
+    // height (as int32_t)
+    int32_t height = pindex->nHeight;
+    unsigned char value[sizeof(height)];
+    std::memcpy(value, &height, sizeof(height));
+    payload.push_back(zmq_message_part(value, value + sizeof(height)));
+
+    // prev hash
+    uint256 prev_hash = pindex->GetBlockHeader().hashPrevBlock;
+    zmq_message_part part_prev_hash;
+    for (int i = 31; i >= 0; i--)   
+        part_prev_hash.push_back(prev_hash.begin()[i]);
+    payload.push_back(part_prev_hash);
+
+    return SendMessage(MSG_CHAINHEADERADDED, payload);
+}
\ No newline at end of file
diff --git a/src/zmq/zmqpublishnotifier.h b/src/zmq/zmqpublishnotifier.h
index 278fdb94d..c561d21ef 100644
--- a/src/zmq/zmqpublishnotifier.h
+++ b/src/zmq/zmqpublishnotifier.h
@@ -7,6 +7,9 @@
 
 #include <zmq/zmqabstractnotifier.h>
 
+typedef std::vector<unsigned char> zmq_message_part;
+typedef std::vector<zmq_message_part> zmq_message;
+
 class CBlockIndex;
 
 class CZMQAbstractPublishNotifier : public CZMQAbstractNotifier
@@ -24,6 +27,13 @@ public:
     */
     bool SendMessage(const char *command, const void* data, size_t size);
 
+    /* sends a zmq multipart message with the following parts:
+        * command (aka ZMQ topic)
+        * payload (zero, one or multiple payload parts)
+        * message sequence number
+    */
+    bool SendMessage(const char *command, const std::vector<zmq_message_part>& payload);
+
     bool Initialize(void *pcontext) override;
     void Shutdown() override;
 };
@@ -52,4 +62,46 @@ public:
     bool NotifyTransaction(const CTransaction &transaction) override;
 };
 
+class CZMQPublishMempolAddedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyMempoolTransactionAdded(const CTransaction &transaction, const CAmount fee) override;
+};
+
+class CZMQPublishMempoolRemovedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyMempoolTransactionRemoved(const CTransaction &transaction, const MemPoolRemovalReason reason) override;
+};
+
+class CZMQPublishChainConnectedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyChainBlockConnected(const CBlockIndex *pindex) override;
+};
+
+class CZMQPublishMempolReplacedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyMempoolTransactionReplaced(const CTransaction& replaced, const CAmount replaced_tx_fee, const CTransaction& replacement, const CAmount replacement_tx_fee) override;
+};
+
+class CZMQPublishMempoolConfirmedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyMempoolTransactionConfirmed(const CTransaction &transaction, const CBlockIndex *pindex) override;
+};
+
+class CZMQPublishChainTipChangedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyChainTipChanged(const CBlockIndex *pindex) override;
+};
+
+class CZMQPublishChainHeaderAddedNotifier : public CZMQAbstractPublishNotifier
+{
+public:
+    bool NotifyChainHeaderAdded(const CBlockIndex *pindexHeader) override;
+};
+
 #endif // BITCOIN_ZMQ_ZMQPUBLISHNOTIFIER_H
diff --git a/test/functional/interface_zmq_chainblockconnected.py b/test/functional/interface_zmq_chainblockconnected.py
new file mode 100644
index 000000000..ed1f426f1
--- /dev/null
+++ b/test/functional/interface_zmq_chainblockconnected.py
@@ -0,0 +1,116 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher chainconnected"""
+import struct
+import zmq
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.messages import CTransaction, hash256
+from test_framework.util import assert_equal, connect_nodes, disconnect_nodes
+from io import BytesIO
+from time import sleep
+from random import randint
+
+from test_framework.util_patched_zmq import ZMQSubscriber
+
+def hash256_reversed(byte_str):
+    return hash256(byte_str)[::-1]
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 2
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_basic()
+            self.test_reorg()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_basic(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        subscriber = ZMQSubscriber(socket, b'chainconnected')
+
+        self.log.info("Test patched chainconnected topic")
+
+        # chainconnected should notify for every block connected
+        self.restart_node(0, ['-zmqpub%s=%s' % (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        lastHeight = self.nodes[0].getblockcount()
+        lastHash = self.nodes[0].getblockhash(lastHeight)
+        
+        # Generate 3 block in nodes[0] and receive all notifications
+        genhashes_node0 = self.nodes[0].generatetoaddress(3, ADDRESS_BCRT1_UNSPENDABLE)
+        for block_hash in genhashes_node0:
+            hash, height, prevhash, block = subscriber.receive_multi_payload()
+            assert_equal(struct.unpack("<I", height)[0], lastHeight+1)
+            assert_equal(lastHash, prevhash.hex())
+            assert_equal(block_hash, hash.hex())
+            assert_equal(block_hash, hash256_reversed(block[:80]).hex())
+            # update last height and hash
+            lastHeight += 1
+            lastHash = block_hash
+
+        # allow both nodes to sync
+        connect_nodes(self.nodes[0], 1)
+        sleep(1)
+        disconnect_nodes(self.nodes[0], 1)
+
+    def test_reorg(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        subscriber = ZMQSubscriber(socket, b'chainconnected')
+
+        self.log.info("Reorg testing ZMQ publisher chainconnected")
+
+        # chainconnected should notify for every block connected
+        self.restart_node(0, ['-zmqpub%s=%s' % (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        preForkHeight = self.nodes[0].getblockcount()
+        preForkHash = self.nodes[0].getblockhash(preForkHeight)
+
+        # Generate 10 blocks in nodes[0]
+        self.nodes[0].generatetoaddress(10, ADDRESS_BCRT1_UNSPENDABLE)
+
+        # Generate six blocks in nodes[1]
+        genhashes_node1 = self.nodes[1].generatetoaddress(6, ADDRESS_BCRT1_UNSPENDABLE)
+
+        # Connect nodes[0] to nodes[1]
+        connect_nodes(self.nodes[0], 1)
+
+        # nodes[0] should connect all six blocks generated by nodes[1], even if
+        # nodes[0] has a longer chain
+        for block_hash in genhashes_node1:
+            hash, height, prevhash, block = subscriber.receive_multi_payload()
+            assert_equal(struct.unpack("<I", height)[0], preForkHeight+1)
+            assert_equal(preForkHash, prevhash.hex())
+            assert_equal(block_hash, hash.hex())
+            assert_equal(block_hash, hash256_reversed(block[:80]).hex())
+            # update last height and hash
+            preForkHeight += 1
+            preForkHash = block_hash
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_chainheaderadded.py b/test/functional/interface_zmq_chainheaderadded.py
new file mode 100644
index 000000000..b90ca75d6
--- /dev/null
+++ b/test/functional/interface_zmq_chainheaderadded.py
@@ -0,0 +1,118 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher chainheaderadded"""
+import struct
+import zmq
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.messages import CTransaction, hash256
+from test_framework.util import assert_equal, connect_nodes, disconnect_nodes
+from io import BytesIO
+from time import sleep
+from random import randint
+
+from test_framework.util_patched_zmq import ZMQSubscriber
+
+def hash256_reversed(byte_str):
+    return hash256(byte_str)[::-1]
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 2
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_basic()
+            self.test_reorg()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_basic(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 2000)
+        subscriber = ZMQSubscriber(socket, b'chainheaderadded')
+
+        self.log.info("Test patched chainheaderadded topic")
+
+        # chainheaderadded should notify for every block header added
+        self.restart_node(0, ['-zmqpub%s=%s' % (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        lastHeight = self.nodes[0].getblockcount()
+        lastHash = self.nodes[0].getblockhash(lastHeight)
+        
+        # Generate 3 block in nodes[0] and receive all notifications
+        genhashes_node0 = self.nodes[0].generatetoaddress(3, ADDRESS_BCRT1_UNSPENDABLE)
+        for block_hash in genhashes_node0:
+            hash, height, prev_hash = subscriber.receive_multi_payload()
+            assert_equal(lastHeight+1, struct.unpack("<I", height)[0])
+            assert_equal(lastHash, prev_hash.hex())
+            assert_equal(block_hash, hash.hex())
+            # update last height and hash
+            lastHeight += 1
+            lastHash = block_hash
+            
+        # allow both nodes to sync
+        connect_nodes(self.nodes[0], 1)
+        sleep(1)
+        disconnect_nodes(self.nodes[0], 1)
+
+    def test_reorg(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 1000)
+        subscriber = ZMQSubscriber(socket, b'chainheaderadded')
+
+        self.log.info("Reorg testing ZMQ publisher chainheaderadded")
+
+        # chainheaderadded should notify for every block header added
+        self.restart_node(0, ['-zmqpub%s=%s' % (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        # make sure nodes are disconnected
+        disconnect_nodes(self.nodes[0], 1)
+
+        preForkHeight = self.nodes[0].getblockcount()
+        prevHash = self.nodes[0].getblockhash(preForkHeight)
+
+        # Generate 6 blocks in nodes[0]
+        genhashes_node0 = self.nodes[0].generatetoaddress(6, self.nodes[0].getnewaddress())
+        for _ in genhashes_node0:
+            _ = subscriber.receive_multi_payload()
+        
+        # Generate 3 block in nodes[1]
+        genhashes_node1 = self.nodes[1].generatetoaddress(3, self.nodes[1].getnewaddress())
+
+        # Connect nodes[0] to nodes[1]
+        connect_nodes(self.nodes[0], 1)
+
+        # Receive header notifications about headers in node0 even if it has a longer chain
+        for block_hash in genhashes_node1:
+            hash, height, prev_hash = subscriber.receive_multi_payload()
+            assert_equal(preForkHeight+1, struct.unpack("<I", height)[0])
+            assert_equal(prevHash, prev_hash.hex())
+            assert_equal(block_hash, hash.hex())
+            # update last height and hash
+            preForkHeight += 1
+            prevHash = block_hash
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_chaintipchanged.py b/test/functional/interface_zmq_chaintipchanged.py
new file mode 100644
index 000000000..4791e4ffb
--- /dev/null
+++ b/test/functional/interface_zmq_chaintipchanged.py
@@ -0,0 +1,113 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher chaintipchaged"""
+import struct
+import zmq
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.messages import CTransaction, hash256
+from test_framework.util import assert_equal, connect_nodes, disconnect_nodes
+from io import BytesIO
+from time import sleep
+from random import randint
+
+from test_framework.util_patched_zmq import ZMQSubscriber
+
+def hash256_reversed(byte_str):
+    return hash256(byte_str)[::-1]
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 2
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_basic()
+            self.test_reorg()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_basic(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        subscriber = ZMQSubscriber(socket, b'chaintipchanged')
+
+        self.log.info("Test patched chaintipchanged topic")
+
+        
+        self.restart_node(0, ['-zmqpub%s=%s' % (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        lastHeight = self.nodes[0].getblockcount()
+        lastHash = self.nodes[0].getblockhash(lastHeight)
+        
+        # Generate 3 block in nodes[0] and receive all notifications
+        genhashes_node0 = self.nodes[0].generatetoaddress(3, ADDRESS_BCRT1_UNSPENDABLE)
+        for block_hash in genhashes_node0:
+            hash, height, prevhash = subscriber.receive_multi_payload()
+            assert_equal(struct.unpack("<I", height)[0], lastHeight+1)
+            assert_equal(lastHash, prevhash.hex())
+            assert_equal(block_hash, hash.hex())
+            # update last height and hash
+            lastHeight += 1
+            lastHash = block_hash
+
+        # allow both nodes to sync
+        connect_nodes(self.nodes[0], 1)
+        self.sync_all()
+        disconnect_nodes(self.nodes[0], 1)
+
+    def test_reorg(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 1000)
+        subscriber = ZMQSubscriber(socket, b'chaintipchanged')
+
+        self.log.info("Reorg testing ZMQ publisher chaintipchanged")
+
+        # chaintipchanged should notify when the block tip changes
+        self.restart_node(0, ['-zmqpub%s=%s' % (subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        disconnect_nodes(self.nodes[0], 1)
+
+        # Generate 10 blocks in nodes[0]
+        genhashes_node0 = self.nodes[0].generatetoaddress(10, ADDRESS_BCRT1_UNSPENDABLE)
+        for _ in genhashes_node0:
+            subscriber.receive_multi_payload()
+
+        # Generate six different blocks in nodes[1]
+        self.nodes[1].sendtoaddress(ADDRESS_BCRT1_UNSPENDABLE, 1)
+        self.nodes[1].generatetoaddress(6, ADDRESS_BCRT1_UNSPENDABLE)
+
+        # Connect nodes[0] to nodes[1]
+        connect_nodes(self.nodes[0], 1)
+
+
+        # nodes[0] should not change the tip for a block generated by nodes[1],
+        # as nodes[0] has a longer chain
+        try:
+            subscriber.receive_multi_payload()
+        except zmq.error.Again as e:
+            self.log.info("ZMQ subscriber timed out as expected: {}".format(e))
+    
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempooladd.py b/test/functional/interface_zmq_mempooladd.py
new file mode 100644
index 000000000..5e44ea0c4
--- /dev/null
+++ b/test/functional/interface_zmq_mempooladd.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+"""Test the ZMQ publisher mempooladded to notify us on a transaction (and its
+fee) that was added to the mempool"""
+
+import zmq
+import struct
+from time import sleep
+from random import randint
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.messages import CTransaction, COIN
+from test_framework.util import assert_equal
+from io import BytesIO
+from test_framework.util_patched_zmq import ZMQSubscriber
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_added()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_added(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+
+        # Subscribe to the 'mempooladded' topic
+        self.log.info("Testing ZMQ publisher mempooladded")
+        subscriber = ZMQSubscriber(socket, b"mempooladded")
+
+        self.restart_node(0, ["-zmqpub{}={}".format(subscriber.topic.decode(), address)])
+        socket.connect(address)
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+
+        node = self.nodes[0]
+        txid = node.sendtoaddress(node.getnewaddress(), 1.0)
+        self.sync_all()
+
+        # Should receive a payload with three elements (txid rawtx, fee)
+        payload = subscriber.receive_multi_payload()
+        assert_equal(3, len(payload))
+
+        # First payload element should be the txid
+        r_txid = payload[0]
+        assert_equal(txid, r_txid.hex())
+
+        # Second payload element should be the raw transaction
+        r_rawtx = payload[1]
+        tx = CTransaction()
+        tx.deserialize(BytesIO(r_rawtx))
+        tx.calc_sha256()
+        assert_equal(txid, tx.hash)
+
+        # Third payload element should be the transaction fee
+        r_fee = struct.unpack('<q', payload[2])[-1]
+        assert_equal(int(node.getmempoolentry(txid)["fee"] * COIN), r_fee)
+
+        self.log.info("Test the getzmqnotifications RPC for mempooladded")
+        assert_equal(node.getzmqnotifications(), [{"type": "pubmempooladded", "address": address, "hwm": 1000}])
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolconfirmed.py b/test/functional/interface_zmq_mempoolconfirmed.py
new file mode 100644
index 000000000..54ae92823
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolconfirmed.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolconfirmed to notify us on a transaction that
+was included in a block and thus removed from the mempool"""
+
+from random import randint
+from time import sleep, time
+import struct
+import zmq
+
+from test_framework.test_framework import BitcoinTestFramework, assert_equal
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 22222))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b'mempoolconfirmed'
+
+        arg_zmq_mempoolconfirmed = "-zmqpub%s=%s" % (    
+            topic.decode(), address)
+
+        node0 = self.nodes[0]
+
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_zmq_mempoolconfirmed, "-txindex"])
+        sleep(0.2)
+        socket.connect(address)
+
+        prev_hash = node0.getbestblockhash()
+
+        self.log.info("Testing mempoolconfirmed")
+        txid = node0.sendtoaddress(node0.getnewaddress(), 1.0)
+        hash = node0.generatetoaddress(1, node0.getnewaddress())
+
+        raw = node0.getrawtransaction(txid)
+        height = node0.getblockcount()
+
+
+
+        r_txid, r_raw, r_height, r_hash, r_prev_hash = subscriber.receive_multi_payload()
+        assert_equal(txid, r_txid.hex())
+        assert_equal(raw, r_raw.hex())
+        assert_equal(height, struct.unpack("<I", r_height)[0])
+        assert_equal(hash[0], r_hash.hex())
+        assert_equal(prev_hash, r_prev_hash.hex())
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_block.py b/test/functional/interface_zmq_mempoolremove_block.py
new file mode 100755
index 000000000..30808880e
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_block.py
@@ -0,0 +1,60 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify us on a transaction that
+was included in a block and thus removed from the mempool"""
+
+from random import randint
+from time import sleep, time
+
+import zmq
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 22222))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b'mempoolremoved'
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (    
+            topic.decode(), address)
+
+        node0 = self.nodes[0]
+
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_zmq_mempoolremoved])
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Testing mempoolremoved BLOCK")
+        txid = node0.sendtoaddress( node0.getnewaddress(), 1.0)
+        node0.generatetoaddress(1, node0.getnewaddress())
+
+        expected = {txid: 'BLOCK'}
+        subscriber.check_mempoolremoved_messages(expected)
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_conflict.py b/test/functional/interface_zmq_mempoolremove_conflict.py
new file mode 100755
index 000000000..51bb92551
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_conflict.py
@@ -0,0 +1,114 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify us on a transaction that
+was removed from the the mempool due to a conflict with an in-block
+transaction"""
+
+import zmq
+from time import sleep
+from random import randint
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, connect_nodes, find_vout_for_address, disconnect_nodes
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 2
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def receive_removed_transaction(self, zmq_subscriber):
+        # Should receive a payload with two elements (rawtx, removal reason)
+        payload = zmq_subscriber.receive_multi_payload()
+        assert_equal(2, len(payload))
+
+        # First payload element should be the raw transaction
+        rawtx = payload[0]
+        tx = CTransaction()
+        tx.deserialize(BytesIO(rawtx))
+        tx.calc_sha256()
+
+        # Second payload element should be the removal reason
+        reason = struct.unpack('<I', payload[1])[-1]
+
+        return [tx.hash, reason]
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (topic.decode(), address)
+        arg_txindex = "-txindex=1"
+
+        node0 = self.nodes[0]
+        node1 = self.nodes[1]
+        
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_txindex, arg_zmq_mempoolremoved])
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Testing mempoolremoved CONFLICT")
+        connect_nodes(node0, 1)
+        self.sync_all()
+
+        # create an utxo that the in-block and the in-mempool transaction
+        # will spend
+        utxo_address = node0.getnewaddress()
+        utxo_txid = node0.sendtoaddress(utxo_address, 1.0)
+        node0.generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)
+        # discard zmq messages for removed tx for block inclusion
+        subscriber.discard_mempoolremoved_message_block()
+
+        # create two different transactions spending the same UTXO
+        txns = []
+        vout = find_vout_for_address(node0, utxo_txid, utxo_address)
+        inputs = [{'txid': utxo_txid, 'vout': vout}]
+        for _ in range(2):
+            outputs = {node0.getnewaddress(): 0.99}
+            raw = node0.createrawtransaction(inputs, outputs)
+            signed = node0.signrawtransactionwithwallet(raw)["hex"]
+            txns.append(signed)
+
+        # disconnect the nodes
+        self.sync_all()
+        disconnect_nodes(node0, 1)
+        self.log.info("Nodes disconnected")
+
+        # node1: broadcast the first tx and then mine a block on 
+        node1.sendrawtransaction(txns[0])
+        node1.generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]
+
+        # node0: broadcast the in-mempool tx
+        inmempool_txid = node0.sendrawtransaction(txns[1])
+
+        # re-connect the nodes
+        connect_nodes(node0, 1)
+
+        # The ZMQ interface should receive the in-mempool tx that conflicts
+        # with the in-block transaction
+        expected = {inmempool_txid: 'CONFLICT'}
+        subscriber.check_mempoolremoved_messages(expected)
+
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_expiry.py b/test/functional/interface_zmq_mempoolremove_expiry.py
new file mode 100755
index 000000000..a94d69854
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_expiry.py
@@ -0,0 +1,108 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify us on a transaction that
+expired from the mempool"""
+
+from random import randint
+from time import sleep, time
+
+import zmq
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, find_vout_for_address
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (
+            topic.decode(), address)
+
+        node = self.nodes[0]
+
+        self.log.info("Testing ZMQ publisher mempoolremoved")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_zmq_mempoolremoved])
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info(
+            "Testing the getzmqnotifications RPC for mempoolremoved")
+        assert_equal(node.getzmqnotifications(), [
+                        {"type": "pubmempoolremoved", "address": address, "hwm": 1000}])
+
+        self.log.info("Testing removal reason EXPIRY")
+        DEFAULT_MEMPOOL_EXPIRY = 336
+
+        # Send a parent transaction that will expire.
+        parent_address = node.getnewaddress()
+        parent_txid = node.sendtoaddress(parent_address, 1.0)
+
+        # Set the mocktime to the arrival time of the parent transaction.
+        entry_time = node.getmempoolentry(parent_txid)["time"]
+        node.setmocktime(entry_time)
+
+        # Create child transaction spending the parent transaction
+        vout = find_vout_for_address(node, parent_txid, parent_address)
+        inputs = [{'txid': parent_txid, 'vout': vout}]
+        outputs = {node.getnewaddress(): 0.99}
+        child_raw = node.createrawtransaction(inputs, outputs)
+        child_signed = node.signrawtransactionwithwallet(child_raw)["hex"]
+
+        # Let half of the timeout elapse and broadcast the child transaction.
+        half_expiry_time = entry_time + \
+            int(60 * 60 * DEFAULT_MEMPOOL_EXPIRY/2)
+        node.setmocktime(half_expiry_time)
+        child_txid = node.sendrawtransaction(child_signed)
+
+        # Let most of the timeout elapse and check that the parent tx is still
+        # in the mempool.
+        nearly_expiry_time = entry_time + 60 * 60 * DEFAULT_MEMPOOL_EXPIRY - 5
+        node.setmocktime(nearly_expiry_time)
+        # Expiry of mempool transactions is only checked when a new transaction
+        # is added to the to the mempool.
+        node.sendtoaddress(node.getnewaddress(), 1.0)
+        assert_equal(entry_time, node.getmempoolentry(parent_txid)["time"])
+
+        # Transaction should be evicted from the mempool after the expiry time
+        # has passed.
+        expiry_time = entry_time + 60 * 60 * DEFAULT_MEMPOOL_EXPIRY + 5
+        node.setmocktime(expiry_time)
+        # Expiry of mempool transactions is only checked when a new transaction
+        # is added to the to the mempool.
+        node.sendtoaddress(node.getnewaddress(), 1.0)
+
+        # The ZMQ interface should receive two removed transactions (the
+        # parent and the child), however we don't know the removal order
+        expected = {parent_txid: 'EXPIRY', child_txid: 'EXPIRY'}
+        subscriber.check_mempoolremoved_messages(expected)
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_reorg.py b/test/functional/interface_zmq_mempoolremove_reorg.py
new file mode 100755
index 000000000..436606bd7
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_reorg.py
@@ -0,0 +1,96 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify us on a transaction that
+was removed from the the mempool in a reorg"""
+
+
+from random import randint
+from time import sleep
+
+import zmq
+
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import assert_equal, find_vout_for_address
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (    
+            topic.decode(), address)
+        arg_txindex = "-txindex=1"
+
+        node = self.nodes[0]
+
+        self.log.info("Testing ZMQ publisher mempoolremoved")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0,[arg_txindex, arg_zmq_mempoolremoved])
+        sleep(0.2)
+        socket.connect(address)
+
+        # Test that transactions removed from our mempool due to a reorg are notified
+        # There are several other reasons a tx could be removed for REORG:
+        # - a spend from a coinbase output that is no longer mature (>100 confirmations)
+        # - a descendants of non-final and non-mature outputs.
+        # - if the re-org has been deep enough that the disconnect pool has filled up
+        # - if the standardness or consensus rules have changed across the reorg
+        # - and probably more...
+        # We only test the non-final case.
+        self.log.info("Testing removal reason REORG (tx non-final after reorg)")
+
+        # create an output to spend from
+        address = node.getnewaddress()  
+        included_in_block_txid = node.sendtoaddress(address, 1.0)
+        tip = node.generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]
+        # discard zmq messages for removed tx for block inclusion
+        subscriber.discard_mempoolremoved_message_block()
+
+        # spend output from tx from the just mined block
+        vout = find_vout_for_address(node, included_in_block_txid, address)
+        inputs = [{'txid': included_in_block_txid, 'vout': vout}]
+        outputs = {node.getnewaddress(): 0.99}
+        # set a locktime of the current height
+        locktime = node.getblockcount()
+        raw = node.createrawtransaction(inputs, outputs, locktime)
+        signed = node.signrawtransactionwithwallet(raw)["hex"]
+        mempool_to_be_reorged_txid = node.sendrawtransaction(signed)
+
+        # invalidate the mined block
+        node.invalidateblock(tip)
+        
+        # The ZMQ interface should receive the transaction that is reorged as 
+        # the transaction is not final anymore
+        expected = {mempool_to_be_reorged_txid: "REORG"}
+        subscriber.check_mempoolremoved_messages(expected)
+        
+        # The mempool should now contain the 'included_in_block_txid' tx
+        assert_equal(True, included_in_block_txid in node.getrawmempool())
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_replaced.py b/test/functional/interface_zmq_mempoolremove_replaced.py
new file mode 100755
index 000000000..31d94a5f9
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_replaced.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify us on a transaction that
+was replaced by another."""
+
+
+import struct
+from io import BytesIO
+from time import sleep, time
+from random import randint
+
+from feature_rbf import make_utxo, txToHex
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.messages import (
+    COIN,
+    COutPoint,
+    CTransaction,
+    CTxIn,
+    CTxOut
+)
+from test_framework.script import CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import (assert_equal, assert_raises_rpc_error,connect_nodes, find_vout_for_address)
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+        self.extra_args = [["-acceptnonstdtxn=1"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (topic.decode(), address)
+        arg_accept_non_standard = "-acceptnonstdtxn=1"
+
+        node = self.nodes[0]
+
+        # create utxo set before we start to listen on mempoolremoved
+        utxo_test_removal_replaced = make_utxo(node, int(1.1*COIN))
+
+        self.log.info("Testing ZMQ publisher mempoolremoved")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_accept_non_standard, arg_zmq_mempoolremoved])
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Testing removal reason REPLACED")
+        # create transaction that will be replaced
+        tx1a = CTransaction()
+        tx1a.vin = [CTxIn(utxo_test_removal_replaced, nSequence=0)]
+        tx1a.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]
+        tx1a_hex = txToHex(tx1a)
+        replaced_txid = node.sendrawtransaction(tx1a_hex, 0)
+
+        # create replacement transaction with an extra 0.1 BTC in fees
+        tx1b = CTransaction()
+        tx1b.vin = [CTxIn(utxo_test_removal_replaced, nSequence=0)]
+        tx1b.vout = [CTxOut(int(0.9 * COIN), CScript([b'b' * 35]))]
+        tx1b_hex = txToHex(tx1b)
+        node.sendrawtransaction(tx1b_hex, 0)
+
+        # The ZMQ interface should receive the removed child transaction
+        expected = {replaced_txid: 'REPLACED'}
+        subscriber.check_mempoolremoved_messages(expected)
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolremove_sizelimit.py b/test/functional/interface_zmq_mempoolremove_sizelimit.py
new file mode 100755
index 000000000..86e3eafa5
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolremove_sizelimit.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ notification mempoolremoved to notify us on a low-fee
+transaction that was removed from the the mempool due to size limiting"""
+
+import zmq
+from time import sleep
+from random import randint
+
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import create_confirmed_utxos, create_lots_of_big_transactions, gen_return_txouts
+
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolremoved"
+
+        arg_zmq_mempoolremoved = "-zmqpub%s=%s" % (topic.decode(), address)
+
+        node0 = self.nodes[0]
+
+        self.log.info("Testing ZMQ publisher mempoolremoved")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0,["-acceptnonstdtxn=1", "-maxmempool=5", "-spendzeroconfchange=0", arg_zmq_mempoolremoved])
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Testing removal reason SIZELIMIT")
+
+        txouts = gen_return_txouts()
+        relayfee = node0.getnetworkinfo()['relayfee']
+        utxos = create_confirmed_utxos(relayfee, node0, 91)
+
+        self.log.info('Create a mempool tx that will be evicted')
+        us0 = utxos.pop()
+        inputs = [{ "txid" : us0["txid"], "vout" : us0["vout"]}]
+        outputs = {node0.getnewaddress() : 0.0001}
+        tx = node0.createrawtransaction(inputs, outputs)
+        node0.settxfee(relayfee) # specifically fund this tx with low fee
+        txF = node0.fundrawtransaction(tx)
+        node0.settxfee(0) # return to automatic fee selection
+        txFS = node0.signrawtransactionwithwallet(txF['hex'])
+        txid = node0.sendrawtransaction(txFS['hex'])
+
+        base_fee = relayfee*100
+        for i in range (3):
+            create_lots_of_big_transactions(node0, txouts, utxos[30*i:30*i+30], 30, (i+1)*base_fee)
+
+        self.log.info('The tx should be evicted by now')
+        # The ZMQ interface should receive the evicted transaction as the
+        # first of multiple evicted transactions
+        expected = {txid: "SIZELIMIT"}
+        subscriber.check_mempoolremoved_messages(expected)
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/interface_zmq_mempoolreplace.py b/test/functional/interface_zmq_mempoolreplace.py
new file mode 100755
index 000000000..74f3c3e3f
--- /dev/null
+++ b/test/functional/interface_zmq_mempoolreplace.py
@@ -0,0 +1,97 @@
+#!/usr/bin/env python3
+# Copyright (c) 2015-2019 The Bitcoin Core developers
+# Distributed under the MIT software license, see the accompanying
+# file COPYING or http://www.opensource.org/licenses/mit-license.php.
+"""Test the ZMQ publisher mempoolremoved to notify us on a transaction that
+was replaced by another."""
+
+
+import struct
+from io import BytesIO
+from time import sleep, time
+from random import randint
+
+from feature_rbf import make_utxo, txToHex
+from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE
+from test_framework.messages import (
+    COIN,
+    COutPoint,
+    CTransaction,
+    CTxIn,
+    CTxOut
+)
+from test_framework.script import CScript
+from test_framework.test_framework import BitcoinTestFramework
+from test_framework.util import (assert_equal, assert_raises_rpc_error,connect_nodes, find_vout_for_address)
+from test_framework.util_patched_zmq import ZMQSubscriber, removalReason
+
+
+class ZMQTest (BitcoinTestFramework):
+    def set_test_params(self):
+        self.num_nodes = 1
+        self.extra_args = [["-acceptnonstdtxn=1"]]
+
+    def skip_test_if_missing_module(self):
+        self.skip_if_no_py3_zmq()
+        self.skip_if_no_bitcoind_zmq()
+        self.skip_if_no_wallet()
+
+    def run_test(self):
+        import zmq
+        self.ctx = zmq.Context()
+        try:
+            self.test_mempool_removed()
+        finally:
+            # Destroy the ZMQ context.
+            self.log.debug("Destroying ZMQ context")
+            self.ctx.destroy(linger=None)
+
+    def test_mempool_removed(self):
+        import zmq
+        address = 'tcp://127.0.0.1:{}'.format(randint(20000, 50000))
+        socket = self.ctx.socket(zmq.SUB)
+        socket.set(zmq.RCVTIMEO, 60000)
+        topic = b"mempoolreplaced"
+
+        arg_zmq_mempoolreplaced = "-zmqpub%s=%s" % (topic.decode(), address)
+        arg_accept_non_standard = "-acceptnonstdtxn=1"
+
+        node = self.nodes[0]
+
+        # create utxo set before we start to listen on mempoolreplaced
+        utxo_value = 1.1*COIN 
+        utxo_test_removal_replaced = make_utxo(node, int(utxo_value))
+
+        self.log.info("Testing ZMQ publisher mempoolreplaced")
+        subscriber = ZMQSubscriber(socket, topic)
+        self.restart_node(0, [arg_accept_non_standard, arg_zmq_mempoolreplaced])
+        # Relax so that the subscriber is ready before publishing zmq messages
+        sleep(0.2)
+        socket.connect(address)
+
+        self.log.info("Testing removal reason REPLACED")
+        # create transaction that will be replaced
+        replaced = CTransaction()
+        replaced.vin = [CTxIn(utxo_test_removal_replaced, nSequence=0)]
+        replaced.vout = [CTxOut(1 * COIN, CScript([b'a' * 35]))]
+        replaced_hex = txToHex(replaced)
+        replaced_txid = node.sendrawtransaction(replaced_hex, 0)
+
+        # create replacement transaction with an extra 0.1 BTC in fees
+        replacement = CTransaction()
+        replacement.vin = [CTxIn(utxo_test_removal_replaced, nSequence=0)]
+        replacement.vout = [CTxOut(int(0.9 * COIN), CScript([b'b' * 35]))]
+        replacement_hex = txToHex(replacement)
+        replacement_txid = node.sendrawtransaction(replacement_hex, 0)
+
+        # The ZMQ interface should receive the replaced notification
+        r_replaced_txid, r_replaced_rawtx, r_replaced_tx_fee, r_replacement_txid, r_replacement_rawtx, r_replacement_tx_fee = subscriber.receive_multi_payload()
+        assert_equal(replaced_txid, r_replaced_txid.hex())
+        assert_equal(replaced_hex, r_replaced_rawtx.hex())
+        assert_equal(int(utxo_value) - replaced.vout[0].nValue, int(struct.unpack("<q", r_replaced_tx_fee)[0]))
+        assert_equal(replacement_txid, r_replacement_txid.hex())
+        assert_equal(replacement_hex, r_replacement_rawtx.hex())
+        assert_equal(int(utxo_value) - replacement.vout[0].nValue, int(struct.unpack("<q", r_replacement_tx_fee)[0]))
+
+if __name__ == '__main__':
+    ZMQTest().main()
diff --git a/test/functional/test_framework/util_patched_zmq.py b/test/functional/test_framework/util_patched_zmq.py
new file mode 100644
index 000000000..1f9cca45f
--- /dev/null
+++ b/test/functional/test_framework/util_patched_zmq.py
@@ -0,0 +1,86 @@
+#!/usr/bin/env python3
+"""Utility functionality for the patched ZMQ interface."""
+
+import struct
+from io import BytesIO
+
+import zmq
+
+from test_framework.messages import COutPoint, CTransaction
+from test_framework.util import assert_equal
+
+removalReason = {
+    'EXPIRY': 0,
+    'SIZELIMIT': 1,
+    'REORG': 2,
+    'BLOCK': 3,
+    'CONFLICT': 4,
+    'REPLACED': 5,
+}
+
+class ZMQSubscriber:
+    def __init__(self, socket, topic):
+        self.sequence = 0
+        self.socket = socket
+        self.topic = topic
+        self.socket.setsockopt(zmq.SUBSCRIBE, self.topic)
+
+    def receive_multi_payload(self):
+        """receives a multipart zmq message with zero, one or multiple payloads
+        and checks the topic and sequence number"""
+        msg = self.socket.recv_multipart()
+
+        # Message should consist of at least two parts (topic and sequence)
+        assert(len(msg) >= 2)
+        topic = msg[0]
+        sequence = msg[-1]
+
+        # Topic should match the subscriber topic.
+        assert_equal(topic, self.topic)
+        # Sequence should be incremental.
+        assert_equal(struct.unpack('<I', sequence)[-1], self.sequence)
+        self.sequence += 1
+        return msg[1:-1]
+
+    def receive_mempoolremoved_message(self):
+        """Retrieves a two-payload ZMQ message from the topic mempoolremoved
+        containing the rawtransaction and the removal reason and returns the txid
+        and the removal reason"""
+        assert_equal(self.topic, b'mempoolremoved')
+
+                # Should receive a payload with three elements (txid, rawtx, removal reason)
+        payload = self.receive_multi_payload()
+        assert_equal(3, len(payload))
+
+        # First payload element should be the txid
+        r_txid = payload[0]
+
+        # Second payload element should be the raw transaction
+        r_rawtx = payload[1]
+        tx = CTransaction()
+        tx.deserialize(BytesIO(r_rawtx))
+        tx.calc_sha256()
+        assert_equal(r_txid.hex(), tx.hash)
+
+        # Second payload element should be the removal reason
+        reason = struct.unpack('<i', payload[2])[-1]
+
+        return [tx.hash, reason]
+
+    def discard_mempoolremoved_message_block(self):
+        """Retrieves one ZMQ message from the subscriber and checks that 
+        it's a transaction removed from the mempool because it confirmed in a
+        block and discards it."""
+
+        assert_equal(self.topic, b'mempoolremoved')
+        _, reason = self.receive_mempoolremoved_message()
+        assert_equal(removalReason["BLOCK"], reason)
+
+    def check_mempoolremoved_messages(self, expected):
+        """checks that the in 'expected' defined txid-reason tuples arrive"""
+        for _ in range(len(expected)):
+            hash, reason = self.receive_mempoolremoved_message()
+            assert_equal(True, hash in expected)
+            assert_equal(removalReason[expected[hash]], reason)
+            del expected[hash]
+        assert_equal(0, len(expected))
diff --git a/test/functional/test_runner.py b/test/functional/test_runner.py
index 2f8279bc2..c02d0df0c 100755
--- a/test/functional/test_runner.py
+++ b/test/functional/test_runner.py
@@ -134,6 +134,12 @@ BASE_SCRIPTS = [
     'wallet_reorgsrestore.py',
     'interface_http.py',
     'interface_rpc.py',
+    'interface_zmq_mempoolremove_block.py',
+    'interface_zmq_mempoolremove_expiry.py',
+    'interface_zmq_mempoolremove_reorg.py',
+    'interface_zmq_mempoolremove_replaced.py',
+    'interface_zmq_mempoolremove_conflict.py',
+    'interface_zmq_mempoolremove_sizelimit.py',
     'rpc_psbt.py',
     'rpc_users.py',
     'feature_proxy.py',
@@ -141,9 +147,11 @@ BASE_SCRIPTS = [
     'wallet_groups.py',
     'p2p_disconnect_ban.py',
     'rpc_decodescript.py',
+    'interface_zmq_mempooladd.py',
     'rpc_blockchain.py',
     'rpc_deprecated.py',
     'wallet_disable.py',
+    'interface_zmq_mempoolconfirmed.py',
     'rpc_net.py',
     'wallet_keypool.py',
     'p2p_mempool.py',
@@ -166,12 +174,15 @@ BASE_SCRIPTS = [
     'mempool_package_onemore.py',
     'rpc_createmultisig.py',
     'feature_versionbits_warning.py',
+    'interface_zmq_chainblockconnected.py',
     'rpc_preciousblock.py',
     'wallet_importprunedfunds.py',
+    'interface_zmq_chaintipchanged.py',
     'p2p_leak_tx.py',
     'rpc_signmessage.py',
     'wallet_balance.py',
     'feature_nulldummy.py',
+    'interface_zmq_mempoolreplace.py',
     'mempool_accept.py',
     'wallet_import_rescan.py',
     'wallet_import_with_label.py',
@@ -192,6 +203,7 @@ BASE_SCRIPTS = [
     'wallet_fallbackfee.py',
     'feature_minchainwork.py',
     'rpc_getblockstats.py',
+    'interface_zmq_chainheaderadded.py',
     'wallet_create_tx.py',
     'p2p_fingerprint.py',
     'feature_uacomment.py',
